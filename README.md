main.js → Electron lifecycle, windows, and app startup
index.js → Backend setup (Express app, middleware, sessions, static files)
routes.js → API endpoints (actual file-organizing logic)


1️⃣ main.js – The Electron “Entry Point”

This is the first file that runs when the Electron app starts.

Responsibilities:

Task	Explanation
Create the main window (BrowserWindow)	Sets up a window of 1200x800 px to display your frontend.
Load frontend	In dev: load http://localhost:3000 (React dev server). In packaged: load index.html inside ASAR.
Start backend server	Starts Express backend (backendApp.listen(PORT)) so frontend can make API calls.
Wait for backend in dev	Uses waitForServer() to ping backend until ready (avoids API failures).
Handle app lifecycle	activate, window-all-closed, quit events, following macOS/Windows conventions.

Summary: main.js is the bridge between Electron frontend and backend, and manages the app lifecycle and windows.


2️⃣ backend/index.js – Express App Initialization

This is your backend server entry point.

Responsibilities:

Task	Explanation
Create Express app	const app = express()
Middleware	Sets up body parsing (express.json()), session handling (express-session), static files (express.static), and rate limiting (express-rate-limit).
Session logs	Session management for logs and undo functionality.
Mount routes	Uses router from routes.js (app.use("/", router)) to handle actual endpoints.
Export app	Exports app without listening, so Electron’s main.js can start it programmatically.

Summary: backend/index.js initializes your backend app, sets middleware, sessions, and links routes.

3️⃣ backend/routes.js – Express Routes / API Endpoints

This handles actual requests from the frontend (Electron window).

Key routes:

Route	Purpose
GET /	Serve index.html (frontend)
POST /preview	Scan a folder and preview how files will be organized without moving them.
POST /organize	Move or copy files based on user rules, logs actions, deletes empty folders.
GET /download-logs	Write session logs to userData/logs.txt and send to user for download.
POST /undo	Undo the last organize operation by moving files back and updating logs.

Summary: routes.js is the API layer that actually manipulates files and communicates with frontend.

Overall Flow / Architecture

User opens app → Electron launches main.js

main.js → starts backend (index.js) and opens frontend window

Frontend sends requests:

/preview → shows what files would be moved

/organize → actually moves/copies files

/undo → reverses last move

/download-logs → saves session logs outside ASAR and downloads

Backend (routes.js) handles requests, updates session logs, manages undo

Electron frontend displays logs, file previews, and status messages


=> Session management :-
Session ID generation:

The secret in .env (or fallback-secret) does not directly become the session ID.

Instead, the secret is used to sign the session ID cookie to prevent tampering.

The session ID itself is a unique random string generated by express-session for each new session.

Where the session ID is stored:

The session ID is sent to the client (Electron window) as a cookie.

Electron automatically stores cookies for that session (just like a browser).

On subsequent requests, the cookie is sent back to the backend, so Express can retrieve the corresponding session data on the server.

Session data storage:

The actual session data (req.session.logs, req.session.lastMoved, etc.) is stored server-side (in memory by default).

Only the session ID is kept client-side in the cookie.

In Electron, the session ID cookie is stored in the renderer process’s cookie store, which is managed by Chromium (the browser engine underlying Electron).

Scalability:-Tens of thousands to a few million files → in-memory Map is fine.
Beyond ~5–10 million files → switch to persistent storage (database) to avoid crashes and memory issues.The Map in your Node.js project is stored entirely in memory (RAM) while your program is running.

It exists only during the runtime of your Node.js process.

Once the program stops, restarts, or crashes, the Map is lost.

Each key-value pair takes up some memory, depending on the size of the key (here, the SHA-256 hash, 32 bytes) and the value (file path string, depends on length).

Map in memory = RAM usage
Key (hash)  → 32 bytes
Value (file path string) → varies
Number of entries × (key + value size) ≈ total RAM used
A string in JavaScript is stored as a sequence of UTF-16 code units.

Each character typically takes 2 bytes in memory (though Node.js may optimize for ASCII).

So the memory used by the value depends on the length of the file path.
Path: "/Users/apeksha/Documents/pdf/one.txt" → 34 characters
Memory: 34 × 2 bytes ≈ 68 bytes


->Since we are storing file hashes (32 bytes each) and file paths (depending on length, say ~50–100 bytes each) in memory using a Map, on a typical machine with a few GBs of RAM, the system can comfortably handle up to around a million files. Beyond that, it would be more efficient to use a persistent storage solution like a database to avoid memory overflow and improve scalability

1 GB = 1,073,741,824 bytes (i.e., 1024^3 bytes). ✅

So if each file hash is 32 bytes, you can roughly calculate how many file hashes fit in 1 GB.

Number of hashes≈33,554,432

That’s over 33 million hashes just for the SHA-256 values alone. If you include file paths and Map overhead, the practical limit will be lower, but it still confirms that handling up to a million files in memory is very safe.

| Component                                              | Approximate Memory per File                                                          |
| ------------------------------------------------------ | ------------------------------------------------------------------------------------ |
| SHA-256 hash (`seenHashes` key)                        | 32 bytes                                                                             |
| File path string (`seenHashes` value)                  | \~150 bytes (depends on folder depth, average 50–100 chars → 2 bytes per char in JS) |
| `session.lastMoved` object (2 paths + object overhead) | \~250 bytes                                                                          |
| `session.logs` entry (log message)                     | \~100 bytes                                                                          |
| Internal JS Map/Array overhead                         | \~50 bytes                                                                           |

Total per file ≈ 32 + 150 + 250 + 100 + 50 = ~582 bytes